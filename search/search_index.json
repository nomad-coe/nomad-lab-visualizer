{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"NOMAD-visu: A Python package for atomistic data visualisation","text":"<p>Two line description of the project. One figure.</p>"},{"location":"#features","title":"Features","text":""},{"location":"#installation","title":"Installation","text":"<p>You can install the package using <code>pip</code>:</p> <pre><code>pip install nomad-visu\n</code></pre>"},{"location":"development/","title":"Development","text":"<p>The <code>nomad-vis</code> package is meant to be used in a jupyter <code>notebook</code> environment. This package using <code>ipywidgets</code> for creating the interactive elements and <code>plotly</code> and <code>py3Dmol</code> for the visualisaton of graphs and structures respectively.</p>"},{"location":"development/#creating-python-environment-for-development","title":"Creating python environment for development","text":"<p>You can use <code>conda</code>/<code>mamba</code> or <code>venv</code> to create the Python 3.10 environment. For example, you can use the following command to create a <code>mamba</code> environment for development:</p> <pre><code>mamba create -n nomad-visu-dev python=3.10\n</code></pre> <p>Activate the environment:</p> <pre><code>mamba activate nomad-visu-dev\n</code></pre> <p>Install the  all teh requirements:</p> <pre><code>pip install -r requirements-all.txt\n</code></pre> <p>Finally install the package itself:</p> <pre><code>pip install -e .\n</code></pre>"},{"location":"development/#update-the-development-environment","title":"Update the development environment","text":"<p>Update the requirements using the following command:</p> <pre><code>pip-compile pip-compile --annotation-style=line --extra=dev --extra=docs --extra=test --output-file=requirements-all.txt pyproject.toml\n</code></pre> <p>To update the development environment, you can use the following command:</p> <pre><code>pip-sync requirements-all.txt\n</code></pre>"},{"location":"development/#building-the-documentation","title":"Building the documentation","text":"<p>From the root of the repository, you can build the documentation using the following command:</p> <pre><code>mkdocs build\n</code></pre> <p>or having a real-time preview of the documentation using the following command:</p> <pre><code>mkdocs serve\n</code></pre>"},{"location":"examples/","title":"Examples","text":""},{"location":"examples/#example-1-basic-usage","title":"Example 1: Basic usage","text":""},{"location":"examples/#example-2-regression","title":"Example 2: Regression","text":""},{"location":"examples/#example-3-regression-with-convex-hull","title":"Example 3: Regression with convex hull","text":""},{"location":"examples/#example-4-regression-with-convex-hull-and-smart-fraction","title":"Example 4: Regression with convex hull and smart fraction","text":""},{"location":"overview/","title":"Overview","text":"<p>Goals and principles</p>"},{"location":"overview/#quick-example","title":"Quick example","text":"<p>Visualize octet binaries:</p> <pre><code>import pandas as pd\nfrom nomad_lab_visualizer import Visualizer\n</code></pre> <p>Load the data:</p> <pre><code>df = pd.read_pickle('examples/octet_binaries/df')\n\nregr_line_coefs = [0.11425013108281612, -1.48249992475763]\nintercept = -0.1447151781886926\n</code></pre> <p>Define the features for the plots:</p> <pre><code>features = ['((|IP_B  - EA_B |) / (r_p_A^2))', '((|r_s_A - r_p_B|) / exp(r_s_A))']\n</code></pre> <p>Finally display the visualizer:</p> <pre><code>visualizer = Visualizer(\n    df,\n    features,\n    features,\n    target=\"Classification\",\n    #   path_to_structures='./octet_binaries/structures',\n    regr_line_coefs=[regr_line_coefs, intercept],\n    smart_fract=True,\n    convex_hull=True,\n)\nvisualizer.show()\n</code></pre>"},{"location":"overview/#details-of-the-features","title":"Details of the features","text":"<ul> <li> <p>fractional data</p> </li> <li> <p>convex hull</p> </li> <li> <p>molecular visualiser</p> </li> </ul>"},{"location":"overview/#citation","title":"Citation","text":""},{"location":"references/","title":"References","text":"<p>Visualizer</p> <p>Attributes:</p>    Name Type Description     <code>df</code>   <p>pandas dataframe containing all data to be visualized.</p>   <code>embedding_features</code>   <p>list of features used for embedding.</p>   <code>hover</code>  <code>features</code>  <p>list of features shown while hovering.</p>   <code>target</code>  <code>features</code>  <p>feature used to create traces (same target value - same trace).</p>   <code>path_to_structures</code>   <p>true if dataframe contains a 'structure' columns with path to structures.</p>     Source code in <code>nomad_visu/__init__.py</code> <pre><code>class Visualizer:\n    \"\"\"\n    Visualizer\n\n    Attributes:\n        df: pandas dataframe containing all data to be visualized.\n        embedding_features: list of features used for embedding.\n        hover features: list of features shown while hovering.\n        target: feature used to create traces (same target value - same trace).\n        path_to_structures: true if dataframe contains a 'structure' columns with path to structures.\n    \"\"\"\n\n    def __init__(\n        self,\n        df: pd.DataFrame,\n        embedding_features: list[str],\n        hover_features: list[str],\n        target: str,\n        path_to_structures: bool = False,\n    ):\n\n        self.path_to_structures = path_to_structures\n\n        self.visualizer_config_widgets = ConfigWidgets()\n        self.visualizer_figure = Figure(\n            df, embedding_features, hover_features, target, path_to_structures\n        )\n\n        ConfigWidgets.hover_features = hover_features\n        ConfigWidgets.embedding_features = embedding_features\n        ConfigWidgets.feat_x = ConfigWidgets.embedding_features[0]\n        ConfigWidgets.feat_y = ConfigWidgets.embedding_features[1]\n        ConfigWidgets.fract = self.visualizer_figure.init_fract\n\n        self.visualizer_top_widgets = TopWidgets()\n        self.visualizer_utils_widgets = UtilsWidgets()\n        self.visualizer_viewers_widgets = ViewersWidgets()\n        self.visualizer_utils_button = UtilsButton()\n\n        self.visualizer_top_widgets.observe_changes(\n            self.visualizer_figure, self.visualizer_utils_widgets\n        )\n        self.visualizer_utils_widgets.observe_changes(self.visualizer_figure)\n        self.visualizer_viewers_widgets.observe_changes(self.visualizer_figure)\n        self.visualizer_utils_button.observe_changes(\n            self.visualizer_figure,\n            self.visualizer_utils_widgets,\n            self.visualizer_viewers_widgets,\n        )\n\n    def show(self):\n        \"\"\"\n        Displays the map and all widgets.\n\n        \"\"\"\n\n\n        top_box = self.visualizer_top_widgets.widg_box\n        figure_widget = self.visualizer_figure.FigureWidget\n        utils_box = self.visualizer_utils_widgets.widg_box\n        utils_button = self.visualizer_utils_button.widget\n        viewer_box = self.visualizer_viewers_widgets.widg_box\n\n        top_box.layout.height = \"140px\"\n        top_box.layout.top = \"30px\"\n        utils_button.layout.left = \"50px\"\n        utils_box.layout.border = \"dashed 1px\"\n        utils_box.layout.max_width = \"700px\"\n        utils_box.layout.visibility = \"hidden\"\n\n        # Structure visualizer is displayed only if there is a path to structures\n        if self.path_to_structures:\n            container = widgets.VBox(\n                [\n                    top_box,\n                    figure_widget,\n                    utils_button,\n                    viewer_box,\n                    utils_box,\n                ]\n            )\n\n        else:\n            utils_box.layout.top = \"10px\"\n            container = widgets.VBox(\n                [\n                    top_box,\n                    figure_widget,\n                    utils_button,\n                    utils_box,\n                ]\n            )\n\n        self.visualizer_figure.batch_update(self.visualizer_config_widgets)\n\n        display(container)\n\n        if self.path_to_structures:\n            with self.visualizer_viewers_widgets.windows_output_l.widget:\n                self.visualizer_viewers_widgets.viewer_l.viewer.show()\n            with self.visualizer_viewers_widgets.windows_output_r.widget:\n                self.visualizer_viewers_widgets.viewer_r.viewer.show()\n\n    def add_convex_hull(self):\n        \"\"\"\n        Add convex hull to the map.\n        \"\"\"\n\n        self.visualizer_figure.convex_hull = True\n        self.visualizer_utils_widgets.color_hull.widget.disabled = False\n        self.visualizer_utils_widgets.width_hull.widget.disabled = False\n        self.visualizer_utils_widgets.dash_hull.widget.disabled = False\n\n        self.visualizer_figure.batch_update(self.visualizer_config_widgets)\n\n    def remove_convex_hull(self):\n        \"\"\"\n        Remove convex hull from the map.\n        \"\"\"\n\n        self.visualizer_figure.convex_hull = False\n        self.visualizer_utils_widgets.color_hull.widget.disabled = True\n        self.visualizer_utils_widgets.width_hull.widget.disabled = True\n        self.visualizer_utils_widgets.dash_hull.widget.disabled = True\n\n        self.visualizer_figure.batch_update(self.visualizer_config_widgets)\n\n    def add_regr_line(self, coefs, feat_x, feat_y):\n        \"\"\"\n        Add regression line to the map.\n        \"\"\"\n\n        self.visualizer_figure.add_regr_line(\n            coefs,\n            feat_x,\n            feat_y,\n            self.visualizer_config_widgets,\n            self.visualizer_utils_widgets.color_line.widget,\n            self.visualizer_utils_widgets.width_line.widget,\n            self.visualizer_utils_widgets.dash_line.widget,\n        )\n\n    def remove_regr_line(self, feat_x, feat_y):\n        \"\"\"\n        Remove regression line from the map.\n\n        \"\"\"\n        self.visualizer_figure.remove_regr_line(\n            feat_x,\n            feat_y,\n            self.visualizer_config_widgets,\n            self.visualizer_utils_widgets.color_line.widget,\n            self.visualizer_utils_widgets.width_line.widget,\n            self.visualizer_utils_widgets.dash_line.widget,\n        )\n\n    def optimize_fract(self):\n        \"\"\"\n        Optimize fractional .\n        \"\"\"\n        self.visualizer_figure.optimize_fract(\n            self.visualizer_top_widgets, self.visualizer_config_widgets\n        )\n</code></pre>"},{"location":"references/#nomad_visu.Visualizer.add_convex_hull","title":"<code>add_convex_hull()</code>","text":"<p>Add convex hull to the map.</p>  Source code in <code>nomad_visu/__init__.py</code> <pre><code>def add_convex_hull(self):\n    \"\"\"\n    Add convex hull to the map.\n    \"\"\"\n\n    self.visualizer_figure.convex_hull = True\n    self.visualizer_utils_widgets.color_hull.widget.disabled = False\n    self.visualizer_utils_widgets.width_hull.widget.disabled = False\n    self.visualizer_utils_widgets.dash_hull.widget.disabled = False\n\n    self.visualizer_figure.batch_update(self.visualizer_config_widgets)\n</code></pre>"},{"location":"references/#nomad_visu.Visualizer.add_regr_line","title":"<code>add_regr_line(coefs, feat_x, feat_y)</code>","text":"<p>Add regression line to the map.</p>  Source code in <code>nomad_visu/__init__.py</code> <pre><code>def add_regr_line(self, coefs, feat_x, feat_y):\n    \"\"\"\n    Add regression line to the map.\n    \"\"\"\n\n    self.visualizer_figure.add_regr_line(\n        coefs,\n        feat_x,\n        feat_y,\n        self.visualizer_config_widgets,\n        self.visualizer_utils_widgets.color_line.widget,\n        self.visualizer_utils_widgets.width_line.widget,\n        self.visualizer_utils_widgets.dash_line.widget,\n    )\n</code></pre>"},{"location":"references/#nomad_visu.Visualizer.optimize_fract","title":"<code>optimize_fract()</code>","text":"<p>Optimize fractional .</p>  Source code in <code>nomad_visu/__init__.py</code> <pre><code>def optimize_fract(self):\n    \"\"\"\n    Optimize fractional .\n    \"\"\"\n    self.visualizer_figure.optimize_fract(\n        self.visualizer_top_widgets, self.visualizer_config_widgets\n    )\n</code></pre>"},{"location":"references/#nomad_visu.Visualizer.remove_convex_hull","title":"<code>remove_convex_hull()</code>","text":"<p>Remove convex hull from the map.</p>  Source code in <code>nomad_visu/__init__.py</code> <pre><code>def remove_convex_hull(self):\n    \"\"\"\n    Remove convex hull from the map.\n    \"\"\"\n\n    self.visualizer_figure.convex_hull = False\n    self.visualizer_utils_widgets.color_hull.widget.disabled = True\n    self.visualizer_utils_widgets.width_hull.widget.disabled = True\n    self.visualizer_utils_widgets.dash_hull.widget.disabled = True\n\n    self.visualizer_figure.batch_update(self.visualizer_config_widgets)\n</code></pre>"},{"location":"references/#nomad_visu.Visualizer.remove_regr_line","title":"<code>remove_regr_line(feat_x, feat_y)</code>","text":"<p>Remove regression line from the map.</p>  Source code in <code>nomad_visu/__init__.py</code> <pre><code>def remove_regr_line(self, feat_x, feat_y):\n    \"\"\"\n    Remove regression line from the map.\n\n    \"\"\"\n    self.visualizer_figure.remove_regr_line(\n        feat_x,\n        feat_y,\n        self.visualizer_config_widgets,\n        self.visualizer_utils_widgets.color_line.widget,\n        self.visualizer_utils_widgets.width_line.widget,\n        self.visualizer_utils_widgets.dash_line.widget,\n    )\n</code></pre>"},{"location":"references/#nomad_visu.Visualizer.show","title":"<code>show()</code>","text":"<p>Displays the map and all widgets.</p>  Source code in <code>nomad_visu/__init__.py</code> <pre><code>def show(self):\n    \"\"\"\n    Displays the map and all widgets.\n\n    \"\"\"\n\n\n    top_box = self.visualizer_top_widgets.widg_box\n    figure_widget = self.visualizer_figure.FigureWidget\n    utils_box = self.visualizer_utils_widgets.widg_box\n    utils_button = self.visualizer_utils_button.widget\n    viewer_box = self.visualizer_viewers_widgets.widg_box\n\n    top_box.layout.height = \"140px\"\n    top_box.layout.top = \"30px\"\n    utils_button.layout.left = \"50px\"\n    utils_box.layout.border = \"dashed 1px\"\n    utils_box.layout.max_width = \"700px\"\n    utils_box.layout.visibility = \"hidden\"\n\n    # Structure visualizer is displayed only if there is a path to structures\n    if self.path_to_structures:\n        container = widgets.VBox(\n            [\n                top_box,\n                figure_widget,\n                utils_button,\n                viewer_box,\n                utils_box,\n            ]\n        )\n\n    else:\n        utils_box.layout.top = \"10px\"\n        container = widgets.VBox(\n            [\n                top_box,\n                figure_widget,\n                utils_button,\n                utils_box,\n            ]\n        )\n\n    self.visualizer_figure.batch_update(self.visualizer_config_widgets)\n\n    display(container)\n\n    if self.path_to_structures:\n        with self.visualizer_viewers_widgets.windows_output_l.widget:\n            self.visualizer_viewers_widgets.viewer_l.viewer.show()\n        with self.visualizer_viewers_widgets.windows_output_r.widget:\n            self.visualizer_viewers_widgets.viewer_r.viewer.show()\n</code></pre>          <p>         Bases: <code>ConfigWidgets</code></p>  Source code in <code>nomad_visu/top_widgets/__init__.py</code> <pre><code>class TopWidgets(ConfigWidgets):\n    def __init__(self):\n\n        self.featx = Featx()\n        self.featy = Featy()\n        self.fract_slider = FractSlider()\n        self.label_fract = LabelFract()\n        self.feat_color = FeatColor()\n        self.feat_color_type = FeatColorType()\n        self.feat_color_list = FeatColorList()\n        self.feat_marker = FeatMarker()\n        self.feat_marker_min = FeatMarkerMin()\n        self.feat_marker_min_label = FeatMarkerMinLabel()\n        self.feat_marker_max = FeatMarkerMax()\n        self.feat_marker_max_label = FeatMarkerMaxLabel()\n\n        self.widg_box = widgets.VBox(\n            [\n                widgets.HBox(\n                    [\n                        widgets.VBox(\n                            [\n                                self.featx.widget,\n                                self.featy.widget,\n                                widgets.HBox(\n                                    [self.label_fract.widget, self.fract_slider.widget]\n                                ),\n                            ]\n                        ),\n                        widgets.VBox(\n                            [\n                                self.feat_color.widget,\n                                widgets.HBox(\n                                    [\n                                        self.feat_color_type.widget,\n                                        self.feat_color_list.widget,\n                                    ],\n                                    layout=widgets.Layout(top=\"10px\"),\n                                ),\n                            ]\n                        ),\n                        widgets.VBox(\n                            [\n                                self.feat_marker.widget,\n                                widgets.VBox(\n                                    [\n                                        widgets.HBox(\n                                            [\n                                                self.feat_marker_min_label.widget,\n                                                self.feat_marker_min.widget,\n                                            ],\n                                        ),\n                                        widgets.HBox(\n                                            [\n                                                self.feat_marker_max_label.widget,\n                                                self.feat_marker_max.widget,\n                                            ],\n                                        ),\n                                    ]\n                                ),\n                            ]\n                        ),\n                    ]\n                ),\n            ]\n        )\n\n    def observe_changes(self, figure, visualizer_utils_widgets):\n\n        self.featx.observe_change(\n            figure,\n            self.fract_slider.widget,\n            visualizer_utils_widgets.color_line.widget,\n            visualizer_utils_widgets.width_line.widget,\n            visualizer_utils_widgets.dash_line.widget,\n        )\n        self.featy.observe_change(\n            figure,\n            self.fract_slider.widget,\n            visualizer_utils_widgets.color_line.widget,\n            visualizer_utils_widgets.width_line.widget,\n            visualizer_utils_widgets.dash_line.widget,\n        )\n        self.fract_slider.observe_change(figure)\n        self.feat_color.observe_change(\n            figure, self.feat_color_type.widget, self.feat_color_list.widget\n        )\n        self.feat_color_type.observe_change(figure, self.feat_color_list.widget)\n        self.feat_color_list.observe_change(figure)\n        self.feat_marker.observe_change(\n            figure, self.feat_marker_min.widget, self.feat_marker_max.widget\n        )\n        self.feat_marker_min.observe_change(figure, self.feat_marker_max.widget)\n        self.feat_marker_max.observe_change(figure, self.feat_marker_min.widget)\n</code></pre>         <p>         Bases: <code>object</code></p>  Source code in <code>nomad_visu/config_widgets.py</code> <pre><code>class ConfigWidgets(object):\n\n    # Default value of the background color\n    bg_color_default = \"rgba(229,236,246, 0.5)\"\n    # List of possible marker symbols\n    symbols_list = [\n        \"circle\",\n        \"circle-open\",\n        \"circle-dot\",\n        \"circle-open-dot\",\n        \"circle-cross\",\n        \"circle-x\",\n        \"square\",\n        \"square-open\",\n        \"square-dot\",\n        \"square-open-dot\",\n        \"square-cross\",\n        \"square-x\",\n        \"diamond\",\n        \"diamond-open\",\n        \"diamond-dot\",\n        \"diamond-open-dot\",\n        \"diamond-cross\",\n        \"diamond-x\",\n        \"triangle-up\",\n        \"triangle-up-open\",\n        \"triangle-up-dot\",\n        \"triangle-up-open-dot\",\n        \"triangle-down\",\n        \"triangle-down-open\",\n        \"triangle-down-dot\",\n        \"triangle-down-open-dot\",\n    ]\n    # List of possible colors of the hulls\n    color_hull = [\n        \"Black\",\n        \"Blue\",\n        \"Cyan\",\n        \"Green\",\n        \"Grey\",\n        \"Orange\",\n        \"Red\",\n        \"Yellow\",\n    ]\n    # List of possible colors of the regression line\n    color_line = [\n        \"Black\",\n        \"Blue\",\n        \"Cyan\",\n        \"Green\",\n        \"Grey\",\n        \"Orange\",\n        \"Red\",\n        \"Yellow\",\n    ]\n    # List of possible dash types for the regression line\n    line_dashs = [\"dash\", \"solid\", \"dot\", \"longdash\", \"dashdot\", \"longdashdot\"]\n    # List of possible dash types for the hulls\n    hull_dashs = [\"dash\", \"solid\", \"dot\", \"longdash\", \"dashdot\", \"longdashdot\"]\n    # List of possible font families\n    font_families = [\n        \"Arial\",\n        \"Courier New\",\n        \"Helvetica\",\n        \"Open Sans\",\n        \"Times New Roman\",\n        \"Verdana\",\n    ]\n    # List of possible font colors\n    font_colors = [\n        \"Black\",\n        \"Blue\",\n        \"Cyan\",\n        \"Green\",\n        \"Grey\",\n        \"Orange\",\n        \"Red\",\n        \"Yellow\",\n    ]\n    # List of possible discrete palette colors\n    discrete_palette_colors = [\n        \"Plotly\",\n        \"D3\",\n        \"G10\",\n        \"T10\",\n        \"Alphabet\",\n        \"Dark24\",\n        \"Light24\",\n        \"Set1\",\n        \"Pastel1\",\n        \"Dark2\",\n        \"Set2\",\n        \"Pastel2\",\n        \"Set3\",\n        \"Antique\",\n        \"Bold\",\n        \"Pastel\",\n        \"Prism\",\n        \"Safe\",\n        \"Vivid\",\n    ]\n    # List of possible continuous gradient colors\n    continuous_gradient_colors = px.colors.named_colorscales()\n\n    # Values below are initialized to a specific value that can be modified using widgets\n    hover_features = []\n    embedding_features = []\n    feat_x = \"\"\n    feat_y = \"\"\n    marker_size = 7  # size of all markers\n    cross_size = 15  # size of the crosses\n    min_value_markerfeat = (\n        4  # min value of markers size if sizes represent a certain feature value\n    )\n    max_value_markerfeat = (\n        20  # max value of markers size if sizes represent a certain feature value\n    )\n\n    font_size = 12  # size of fonts\n    hull_width = 1  # width of the  the convex hull\n    line_width = 1  # width of the regression line\n    hull_dash = \"solid\"  # dash of the convex hull\n    line_dash = \"dash\"  # dash of the regression line\n    hull_color = \"Grey\"  # color of the convex hull\n    line_color = \"Black\"  # color of the regression line\n    bg_color = \"rgba(229,236,246, 0.5)\"  # background color\n    bg_toggle = True  # background color is shown\n    structures_list = []\n    replica_l = 0  # which file in the list is shown in the left visualizer\n    replica_r = 0  # which file in the list is shown in the right visualizer\n    fract = 1  # fraction of points visualized on the map\n    palette = cycle(\n        getattr(px.colors.qualitative, discrete_palette_colors[0])\n    )  #  color palette used for the initial values\n    color_palette = discrete_palette_colors[0]\n    font_family = font_families[0]\n    font_color = font_colors[0]\n\n    structure_text_l = \"...\"\n    structure_text_r = \"...\"\n\n    featmarker = \"Default size\"  # feature used for markers size\n    featcolor = \"Default color\"  # feature used for markers color\n    featcolor_type = \"Gradient\"  # if a feature is used for color this can be 'Gradient' for continuous feature values or 'Discrete'\n    featcolor_list = \"viridis\"  # color palette used for features\n</code></pre>         <p>         Bases: <code>ConfigWidgets</code></p>  Source code in <code>nomad_visu/utils_widgets/__init__.py</code> <pre><code>class UtilsWidgets(ConfigWidgets):\n    def __init__(self):\n\n        self.bg_color = BgColor()\n        self.bg_color_update = BgColorUpdate()\n        self.bg_toggle = BgToggle()\n        self.color_hull = ColorHull()\n        self.color_line = ColorLine()\n        self.color_palette = ColorPalette()\n        self.cross_size = CrossSize()\n        self.dash_hull = DashHull()\n        self.dash_line = DashLine()\n        self.font_color = FontColor()\n        self.font_family = FontFamily()\n        self.font_size = FontSize()\n        self.markers_size = MarkersSize()\n        self.markers_symbol = MarkersSymbol()\n        self.plot_format = PlotFormat()\n        self.plot_name = PlotName()\n        self.plot_resolution = PlotResolution()\n        self.print = Print()\n        self.print_label = PrintLabel()\n        self.print_output = PrintOutput()\n        self.reset_button = ResetButton()\n        self.trace_symbol = TraceSymbol()\n        self.width_hull = WidthHull()\n        self.width_line = WidthLine()\n        self.window_label = WindowLabel()\n\n        self.color_hull.widget.disabled = True\n        self.width_hull.widget.disabled = True\n        self.dash_hull.widget.disabled = True\n\n        self.color_line.widget.disabled = True\n        self.width_line.widget.disabled = True\n        self.dash_line.widget.disabled = True\n\n        self.widg_box = widgets.VBox(\n            [\n                widgets.HBox(\n                    [\n                        self.markers_size.widget,\n                        self.cross_size.widget,\n                        self.color_palette.widget,\n                    ]\n                ),\n                widgets.HBox(\n                    [\n                        self.font_size.widget,\n                        self.font_family.widget,\n                        self.font_color.widget,\n                    ]\n                ),\n                widgets.HBox(\n                    [\n                        self.trace_symbol.widget,\n                        self.markers_symbol.widget,\n                        self.reset_button.widget,\n                    ]\n                ),\n                widgets.HBox(\n                    [\n                        self.color_hull.widget,\n                        self.width_hull.widget,\n                        self.dash_hull.widget,\n                    ]\n                ),\n                widgets.HBox(\n                    [\n                        self.color_line.widget,\n                        self.width_line.widget,\n                        self.dash_line.widget,\n                    ]\n                ),\n                widgets.HBox(\n                    [\n                        self.bg_toggle.widget,\n                        self.bg_color.widget,\n                        self.bg_color_update.widget,\n                    ]\n                ),\n                self.print_label.widget,\n                widgets.HBox(\n                    [\n                        self.plot_name.widget,\n                        self.plot_format.widget,\n                        self.plot_resolution.widget,\n                    ]\n                ),\n                self.print.widget,\n                self.print_output.widget,\n            ]\n        )\n\n    def observe_changes(self, Figure):\n\n        self.bg_color_update.observe_change(Figure, self.bg_color)\n        self.bg_toggle.observe_change(Figure)\n        self.color_hull.observe_change(Figure)\n        self.color_line.observe_change(Figure)\n        self.color_palette.observe_change(Figure)\n        self.cross_size.observe_change(Figure)\n        self.dash_hull.observe_change(Figure)\n        self.dash_line.observe_change(Figure)\n        self.font_color.observe_change(Figure)\n        self.font_family.observe_change(Figure)\n        self.font_size.observe_change(Figure)\n        self.markers_size.observe_change(Figure)\n        self.markers_symbol.observe_change(Figure, self.trace_symbol)\n        self.print.observe_change(\n            Figure,\n            self.print_output,\n            self.plot_name,\n            self.plot_format,\n            self.plot_resolution,\n        )\n        self.reset_button.observe_change(Figure)\n        self.trace_symbol.observe_change(Figure)\n        self.width_hull.observe_change(Figure)\n        self.width_line.observe_change(Figure)\n</code></pre>         <p>         Bases: <code>ConfigWidgets</code></p>  Source code in <code>nomad_visu/viewers_widgets/__init__.py</code> <pre><code>class ViewersWidgets(ConfigWidgets):\n    def __init__(self):\n\n        self.cross_image_l = CrossImageL()\n        self.cross_image_r = CrossImageR()\n        self.display_button_l = DisplayButtonL()\n        self.display_button_r = DisplayButtonR()\n        self.structure_name_l = StructureNameL()\n        self.structure_name_r = StructureNameR()\n        self.viewer_l = ViewerL()\n        self.viewer_r = ViewerR()\n        self.windows_checkbox_l = WindowsCheckboxL()\n        self.windows_checkbox_r = WindowsCheckboxR()\n        self.windows_label = WindowsLabel()\n        self.windows_output_l = WindowsOutputL()\n        self.windows_output_r = WindowsOutputR()\n\n        self.widg_box = widgets.VBox(\n            [\n                self.windows_label.widget,\n                widgets.HBox(\n                    [\n                        widgets.VBox(\n                            [\n                                widgets.HBox(\n                                    [\n                                        self.structure_name_l.widget,\n                                        self.display_button_l.widget,\n                                        self.cross_image_l.widget,\n                                        self.windows_checkbox_l.widget,\n                                    ]\n                                ),\n                                self.windows_output_l.widget,\n                            ]\n                        ),\n                        widgets.VBox(\n                            [\n                                widgets.HBox(\n                                    [\n                                        self.structure_name_r.widget,\n                                        self.display_button_r.widget,\n                                        self.cross_image_r.widget,\n                                        self.windows_checkbox_r.widget,\n                                    ]\n                                ),\n                                self.windows_output_r.widget,\n                            ]\n                        ),\n                    ]\n                ),\n            ]\n        )\n\n    def observe_changes(self, Figure):\n\n        self.display_button_l.observe_change(\n            Figure, self.viewer_l, self.structure_name_l, self.windows_output_l\n        )\n        self.display_button_r.observe_change(\n            Figure, self.viewer_r, self.structure_name_r, self.windows_output_r\n        )\n        self.windows_checkbox_l.observe_change(self.windows_checkbox_r)\n        self.windows_checkbox_r.observe_change(self.windows_checkbox_l)\n\n        def handle_point_clicked(trace, points, selector):\n            \"\"\"\n            visualizes structure of clicked point and changes its marker symbol to a cross\n            \"\"\"\n\n            if not points.point_inds:\n                return\n\n            trace = points.trace_index\n            formula = Figure.FigureWidget.data[trace].text[points.point_inds[0]]\n            structure = Figure.df.iloc[points.point_inds[0]][\"Structure\"]\n\n            if self.windows_checkbox_l.widget.value:\n                self.structure_name_l.widget.value = formula\n                self.viewer_l.view_structure(formula, Figure, self.windows_output_l)\n            if self.windows_checkbox_r.widget.value:\n                self.structure_name_l.widget.value = formula\n                self.viewer_r.view_structure(formula, Figure, self.windows_output_r)\n\n            Figure.batch_update(self)\n\n        if Figure.path_to_structures:\n            for name_trace in Figure.name_traces:\n                Figure.trace[str(name_trace)].on_click(\n                    handle_point_clicked  # actions performed after clicking points on the map\n                )\n</code></pre>         <p>         Bases: <code>ConfigWidgets</code></p>  Source code in <code>nomad_visu/utils_button.py</code> <pre><code>class UtilsButton(ConfigWidgets):\n    def __init__(self):\n\n        self.widget = widgets.Button(\n            description=\"For a high-quality print of the plot, click to access the plot appearance utils\",\n            layout=widgets.Layout(width=\"600px\"),\n        )\n\n    def observe_changes(\n        self, Figure, visualizer_utils_widgets, visualizer_viewers_widgets\n    ):\n        def button_clicked(button):\n            \"\"\"\n            shows the plot utils box\n            \"\"\"\n\n            if Figure.path_to_structures:\n                if visualizer_utils_widgets.widg_box.layout.visibility == \"visible\":\n                    visualizer_utils_widgets.widg_box.layout.visibility = \"hidden\"\n                    for i in range(340, -1, -1):\n                        visualizer_viewers_widgets.widg_box.layout.top = str(i) + \"px\"\n                    visualizer_utils_widgets.widg_box.layout.bottom = \"0px\"\n                else:\n                    for i in range(341):\n                        visualizer_viewers_widgets.widg_box.layout.top = str(i) + \"px\"\n                    visualizer_utils_widgets.widg_box.layout.bottom = \"460px\"\n                    visualizer_utils_widgets.widg_box.layout.visibility = \"visible\"\n            else:\n                if visualizer_utils_widgets.widg_box.layout.visibility == \"visible\":\n                    visualizer_utils_widgets.widg_box.layout.visibility = \"hidden\"\n                else:\n                    visualizer_utils_widgets.widg_box.layout.visibility = \"visible\"\n\n        self.widget.on_click(button_clicked)\n</code></pre>         <p>         Bases: <code>object</code></p>  Source code in <code>nomad_visu/figure/__init__.py</code> <pre><code>class Figure(object):\n    def __init__(\n        self, df, embedding_features, hover_features, target, path_to_structures\n    ):\n\n        self.df = df.copy()\n        self.embedding_features = embedding_features\n        self.hover_features = hover_features\n        self.path_to_structures = path_to_structures\n        self.target = target\n\n        self.FigureWidget = go.FigureWidget()\n        # Permanent layout settings are defined here\n        self.FigureWidget.update_layout(\n            hoverlabel=dict(bgcolor=\"white\", font_size=16, font_family=\"Rockwell\"),\n            width=800,\n            height=400,\n            margin=dict(l=50, r=50, b=70, t=20, pad=4),\n        )\n        self.FigureWidget.update_xaxes(\n            ticks=\"outside\", tickwidth=1, ticklen=10, linewidth=1, linecolor=\"black\"\n        )\n        self.FigureWidget.update_yaxes(\n            ticks=\"outside\", tickwidth=1, ticklen=10, linewidth=1, linecolor=\"black\"\n        )\n\n        # The 'target' feature is used to divide data into different traces.\n        # Each item in the following dictionaries will be related to a different trace in the dataframe.\n        self.name_traces = self.df[target].unique()\n        # a pair of features (feat_0, feat_1) returns 'True' if a regression line was added for those features\n        self.trace = {}\n        # a pair of features (feat_0, feat_1) returns the values of the regression line for those features\n        self.regr_line_trace = {}\n        # dataframe containing only the elements that are visualized on the map\n        self.df_trace_on_map = {}\n        self.symbols = {}  # list of symbols used for every marker in each trace\n        self.sizes = {}  # list of sizes used for every marker in each trace\n        self.colors = {}  # list of colors used for every marker in each trace\n        self.trace_symbol = {}  # default symbol used for the trace\n\n        # optimized sequence of entries that is visualized varying the fraction for each pair of features.\n        self.optimized_sequence_indexes = {}\n        # optimized initial fraction that is visualized for each pair of features.\n        self.optimized_init_fract = {}\n        # random sequence of entries that is visualized varying the fraction.\n        self.random_permutation_indexes = {}\n\n        self.init_fract = 1\n        total_points = self.df.shape[0]\n        if total_points &gt; 1000:\n            # The initial fraction of visualized points is by default 1, unless there are more than 1000 points.\n            self.init_fract = 1000 / total_points\n\n        self.convex_hull = False\n\n        if path_to_structures:\n            # List of all files found in the directory pointed by 'Structure'.\n            self.df[\"File\"] = self.df[\"Structure\"].apply(lambda x: os.listdir(x))\n            # Number of files found in the directory pointed by 'Structure'.\n            self.df[\"Replicas\"] = self.df[\"Structure\"].apply(\n                lambda x: len(os.listdir(x))\n            )\n\n        # Dictionaries initialized above are compiled for all different trace names.\n        for cl in range(len(self.name_traces)):\n\n            name_trace = str(self.name_traces[cl])\n\n            # A 'Plotly go trace' is constructed and assigned to the 'trace' dictionary.\n            self.FigureWidget.add_trace(\n                go.Scatter(\n                    name=name_trace,\n                    mode=\"markers\",\n                )\n            )\n            self.trace[name_trace] = self.FigureWidget[\"data\"][-1]\n\n            # Add convex hull trace.\n            name_trace = \"Hull \" + name_trace\n            self.FigureWidget.add_trace(\n                go.Scatter(\n                    name=name_trace,\n                )\n            )\n            self.trace[name_trace] = self.FigureWidget[\"data\"][-1]\n\n        for name_trace in self.name_traces:\n\n            self.random_permutation_indexes[name_trace] = self.df.loc[\n                self.df[target] == name_trace\n            ].index.to_numpy()[\n                np.random.permutation(\n                    self.df.loc[self.df[self.target] == name_trace].shape[0]\n                )\n            ]\n\n            n_points = self.df.loc[self.df[target] == name_trace].shape[0]\n\n            self.df_trace_on_map[name_trace] = (\n                self.df.loc[self.df[target] == name_trace]\n                .loc[self.random_permutation_indexes[name_trace]]\n                .head(n_points)\n            )\n\n            self.trace_symbol[\n                name_trace\n            ] = \"circle\"  # Circle is the init symbol used for each trace\n\n    def add_regr_line(\n        self,\n        coefs,\n        feat_x,\n        feat_y,\n        ConfigWidgets,\n        ColorLineWidget,\n        WidthLineWidget,\n        DashLineWidget,\n    ):\n\n        if not (feat_x, feat_y) in self.regr_line_trace:\n\n            self.regr_line_trace[(feat_x, feat_y)] = True\n            line_x, line_y = self.make_line(feat_x, feat_y, coefs)\n\n            name_trace = \"Regr line\" + str(feat_x) + \" \" + str(feat_y)\n            self.FigureWidget.add_trace(\n                go.Scatter(\n                    name=name_trace,\n                    x=line_x,\n                    y=line_y,\n                )\n            )\n            self.trace[name_trace] = self.FigureWidget[\"data\"][-1]\n            self.FigureWidget.update_traces(\n                selector={\"name\": name_trace}, showlegend=False\n            )\n\n        else:\n\n            self.regr_line_trace[(feat_x, feat_y)] = True\n            line_x, line_y = self.make_line(feat_x, feat_y, coefs)\n\n            name_trace = \"Regr line\" + str(feat_x) + \" \" + str(feat_y)\n            self.trace[name_trace].x = line_x\n            self.trace[name_trace].y = line_y\n            self.FigureWidget.update_traces(\n                selector={\"name\": name_trace}, showlegend=False\n            )\n\n        if feat_x == ConfigWidgets.feat_x and feat_y == ConfigWidgets.feat_y:\n            ColorLineWidget.disabled = False\n            WidthLineWidget.disabled = False\n            DashLineWidget.disabled = False\n\n        self.batch_update(ConfigWidgets)\n\n    def remove_regr_line(\n        self,\n        feat_x,\n        feat_y,\n        ConfigWidgets,\n        ColorLineWidget,\n        WidthLineWidget,\n        DashLineWidget,\n    ):\n\n        self.regr_line_trace[(feat_x, feat_y)] = False\n\n        if feat_x == ConfigWidgets.feat_x and feat_y == ConfigWidgets.feat_y:\n            ColorLineWidget.disabled = True\n            WidthLineWidget.disabled = True\n            DashLineWidget.disabled = True\n\n        self.batch_update(ConfigWidgets)\n\n    def optimize_fract(self, visualizerTopWidgets, ConfigWidgets):\n\n        if (\n            not (ConfigWidgets.feat_x, ConfigWidgets.feat_y)\n            in self.optimized_sequence_indexes\n        ):\n            sequence_indexes, init_fract = self.optimize_sequence(\n                ConfigWidgets.feat_x, ConfigWidgets.feat_y\n            )\n\n            self.optimized_sequence_indexes[\n                (ConfigWidgets.feat_x, ConfigWidgets.feat_y)\n            ] = sequence_indexes\n            self.optimized_sequence_indexes[\n                (ConfigWidgets.feat_y, ConfigWidgets.feat_x)\n            ] = sequence_indexes\n            self.optimized_init_fract[\n                (ConfigWidgets.feat_x, ConfigWidgets.feat_y)\n            ] = init_fract\n            self.optimized_init_fract[\n                (ConfigWidgets.feat_y, ConfigWidgets.feat_x)\n            ] = init_fract\n\n            ConfigWidgets.fract = init_fract\n            visualizerTopWidgets.fract_slider.widget.value = init_fract\n            self.batch_update(ConfigWidgets)\n\n    def batch_update(self, ConfigWidgets):\n        \"\"\"\n        Updates the layout of the map according to values stored in \"ConfigWidgets\".\n        \"\"\"\n\n        self.marker_style_updates(ConfigWidgets)\n        self.fract_change_updates(ConfigWidgets)\n\n        x_min = []\n        x_max = []\n        y_min = []\n        y_max = []\n\n        for name_trace in self.name_traces:\n\n            x_min.append(min(self.df_trace_on_map[name_trace][ConfigWidgets.feat_x]))\n            x_max.append(max(self.df_trace_on_map[name_trace][ConfigWidgets.feat_x]))\n            y_min.append(min(self.df_trace_on_map[name_trace][ConfigWidgets.feat_y]))\n            y_max.append(max(self.df_trace_on_map[name_trace][ConfigWidgets.feat_y]))\n\n        x_min = min(x_min)\n        y_min = min(y_min)\n        x_max = max(x_max)\n        y_max = max(y_max)\n        x_delta = 0.05 * abs(x_max - x_min)\n        y_delta = 0.05 * abs(y_max - y_min)\n\n        # range of the x-,y- values that are visualized on the map\n        xaxis_range = [x_min - x_delta, x_max + x_delta]\n        yaxis_range = [y_min - y_delta, y_max + y_delta]\n\n        if ConfigWidgets.bg_toggle:\n            bg_color = ConfigWidgets.bg_color\n            gridcolor = \"white\"\n        else:\n            bg_color = \"white\"\n            gridcolor = \"rgb(229,236,246)\"\n\n        with self.FigureWidget.batch_update():\n\n            self.FigureWidget.update_layout(\n                showlegend=True,\n                plot_bgcolor=bg_color,\n                xaxis=dict(gridcolor=gridcolor, showgrid=True, zeroline=False),\n                yaxis=dict(gridcolor=gridcolor, showgrid=True, zeroline=False),\n                font=dict(\n                    size=int(ConfigWidgets.font_size),\n                    family=ConfigWidgets.font_family,\n                    color=ConfigWidgets.font_color,\n                ),\n                xaxis_title=ConfigWidgets.feat_x,\n                yaxis_title=ConfigWidgets.feat_y,\n                xaxis_range=xaxis_range,\n                yaxis_range=yaxis_range,\n            )\n\n            for name_trace in self.name_traces:\n                # all elements on the map and their properties are reinitialized at each change\n\n                self.FigureWidget.update_traces(\n                    selector={\"name\": str(name_trace)},\n                    text=self.hover_text[name_trace],\n                    customdata=self.hover_custom[name_trace],\n                    hovertemplate=self.hover_template[name_trace],\n                    x=self.df_trace_on_map[name_trace][ConfigWidgets.feat_x],\n                    y=self.df_trace_on_map[name_trace][ConfigWidgets.feat_y],\n                    marker=dict(\n                        size=self.sizes[name_trace], symbol=self.symbols[name_trace]\n                    ),\n                )\n                if (\n                    ConfigWidgets.featcolor != \"Default color\"\n                    and ConfigWidgets.featcolor_type == \"Gradient\"\n                ):\n                    feature = ConfigWidgets.featcolor\n                    gradient = ConfigWidgets.featcolor_list\n                    min_value = self.df[feature].min()\n                    max_value = self.df[feature].max()\n\n                    self.FigureWidget.update_traces(\n                        selector={\"name\": str(name_trace)},\n                        marker=dict(\n                            colorscale=gradient,\n                            showscale=True,\n                            color=self.colors[name_trace],\n                            cmin=min_value,\n                            cmax=max_value,\n                            colorbar=dict(\n                                thickness=10,\n                                orientation=\"v\",\n                                len=0.5,\n                                y=0.25,\n                                title=dict(\n                                    text=feature, side=\"right\", font={\"size\": 10}\n                                ),\n                            ),\n                        ),\n                    )\n                else:\n                    self.FigureWidget.update_traces(\n                        selector={\"name\": str(name_trace)},\n                        marker=dict(showscale=False, color=self.colors[name_trace]),\n                    )\n            if (ConfigWidgets.feat_x, ConfigWidgets.feat_y) in self.regr_line_trace:\n                name_trace = (\n                    \"Regr line\"\n                    + str(ConfigWidgets.feat_x)\n                    + \" \"\n                    + (ConfigWidgets.feat_y)\n                )\n\n                if self.regr_line_trace[(ConfigWidgets.feat_x, ConfigWidgets.feat_y)]:\n                    self.trace[name_trace].line = dict(\n                        color=ConfigWidgets.line_color,\n                        width=ConfigWidgets.line_width,\n                        dash=ConfigWidgets.line_dash,\n                    )\n                else:\n                    self.trace[name_trace].line = dict(width=0)\n\n            if self.convex_hull == True:\n\n                if ConfigWidgets.feat_x == ConfigWidgets.feat_y:\n\n                    for name_trace in self.name_traces:\n\n                        self.trace[\"Hull \" + str(name_trace)].line = dict(width=0)\n                        self.FigureWidget.update_traces(\n                            selector={\"name\": \"Hull \" + name_trace},\n                        )\n                else:\n                    hullx, hully = self.make_hull(\n                        ConfigWidgets.feat_x, ConfigWidgets.feat_y\n                    )\n                    for name_trace in self.name_traces:\n\n                        self.trace[\"Hull \" + str(name_trace)][\"x\"] = hullx[name_trace]\n                        self.trace[\"Hull \" + str(name_trace)][\"y\"] = hully[name_trace]\n                        self.trace[\"Hull \" + str(name_trace)].line = dict(\n                            color=ConfigWidgets.hull_color,\n                            width=ConfigWidgets.hull_width,\n                            dash=ConfigWidgets.hull_dash,\n                        )\n                        self.FigureWidget.update_traces(\n                            selector={\"name\": \"Hull \" + name_trace}, showlegend=False\n                        )\n            else:\n                for name_trace in self.name_traces:\n\n                    self.trace[\"Hull \" + str(name_trace)].line = dict(width=0)\n                    self.FigureWidget.update_traces(\n                        selector={\"name\": \"Hull \" + str(name_trace)},\n                    )\n\n    def fract_change_updates(self, ConfigWidgets):\n        \"\"\"\n        All updates caused by a change in the fraction value.\n        \"\"\"\n\n        self.update_df_on_map(ConfigWidgets)\n        self.update_hover_variables()\n\n    def update_df_on_map(self, ConfigWidgets):\n        \"\"\"\n        Updates the number of points based on the fraction value,\n        then 'df_trace_on_map' which is the fraction of the dataframe that is visualized\n        \"\"\"\n\n        for name_trace in self.name_traces:\n\n            n_points = int(\n                ConfigWidgets.fract\n                * self.df.loc[self.df[self.target] == name_trace].shape[0]\n            )\n\n            if n_points &lt; 1:\n                n_points = 1\n\n            if (\n                ConfigWidgets.feat_x,\n                ConfigWidgets.feat_y,\n            ) in self.optimized_sequence_indexes:\n                sequence_indexes = self.optimized_sequence_indexes[\n                    (ConfigWidgets.feat_x, ConfigWidgets.feat_y)\n                ][name_trace]\n            else:\n                sequence_indexes = self.random_permutation_indexes[name_trace]\n\n            self.df_trace_on_map[name_trace] = (\n                self.df.loc[self.df[self.target] == name_trace]\n                .loc[sequence_indexes]\n                .head(n_points)\n            )\n\n            # if a structure is visualized, its dataframe entry is added to the visualized dataframe 'df_trace_on_map'\n            # this to avoid that the entry relative to a visualized structure is not available on the map\n            if (\n                ConfigWidgets.structure_text_l\n                in self.df.loc[self.df[self.target] == name_trace].index\n            ):\n                self.df_trace_on_map[name_trace] = pd.concat(\n                    [\n                        self.df_trace_on_map[name_trace],\n                        self.df.loc[[ConfigWidgets.structure_text_l]],\n                    ]\n                )\n\n            if (\n                ConfigWidgets.structure_text_r\n                in self.df.loc[self.df[self.target] == name_trace].index\n            ):\n                self.df_trace_on_map[name_trace] = pd.concat(\n                    [\n                        self.df_trace_on_map[name_trace],\n                        self.df.loc[[ConfigWidgets.structure_text_r]],\n                    ]\n                )\n\n    def update_hover_variables(self):\n        \"\"\"\n        Updates the hover data based on the points that are visualized on the map.\n        \"\"\"\n\n        self.hover_text = {}\n        self.hover_custom = {}\n        self.hover_template = {}\n\n        for name_trace in self.name_traces:\n\n            self.hover_text[name_trace] = self.df_trace_on_map[name_trace].index\n            hover_template = r\"&lt;b&gt;%{text}&lt;/b&gt;&lt;br&gt;&lt;br&gt;\"\n            if self.hover_features:\n                hover_custom = np.dstack(\n                    [\n                        self.df_trace_on_map[name_trace][\n                            str(self.hover_features[0])\n                        ].to_numpy()\n                    ]\n                )\n                hover_template += str(self.hover_features[0]) + \": %{customdata[0]}&lt;br&gt;\"\n                for i in range(1, len(self.hover_features), 1):\n                    hover_custom = np.dstack(\n                        [\n                            hover_custom,\n                            self.df_trace_on_map[name_trace][\n                                str(self.hover_features[i])\n                            ].to_numpy(),\n                        ]\n                    )\n                    hover_template += (\n                        str(self.hover_features[i])\n                        + \": %{customdata[\"\n                        + str(i)\n                        + \"]}&lt;br&gt;\"\n                    )\n                self.hover_custom[name_trace] = hover_custom[0]\n                self.hover_template[name_trace] = hover_template\n            else:\n                self.hover_customp[name_trace] = [\"\"]\n                self.hover_template[name_trace] = [\"\"]\n\n    def make_hull(self, feat_x, feat_y):\n\n        xhull_classes = {}\n        yhull_classes = {}\n\n        for name_trace in self.name_traces:\n\n            name_trace = str(name_trace)\n            points = self.df.loc[self.df[self.target] == name_trace][\n                [feat_x, feat_y]\n            ].to_numpy()\n\n            delta_0 = max(points[:, 0]) - min(points[:, 0])\n            delta_1 = max(points[:, 1]) - min(points[:, 1])\n            exp_1 = int(np.log10(delta_0 / delta_1))\n            exp_0 = int(np.log10(delta_1 / delta_0))\n            if exp_1 &gt; 6:\n                points[:, 1] = points[:, 1] * 10**exp_1\n            if exp_0 &gt; 6:\n                points[:, 0] = points[:, 0] * 10**exp_0\n            hull = ConvexHull(points)\n            vertexes = self.df.loc[self.df[self.target] == name_trace][\n                [feat_x, feat_y]\n            ].to_numpy()[hull.vertices]\n\n            x_hullvx = vertexes[:, 0]\n            y_hullvx = vertexes[:, 1]\n            n_intervals = 100\n\n            xhull = np.array([x_hullvx[0]])\n            yhull = np.array([y_hullvx[0]])\n            for xy in zip(x_hullvx, y_hullvx):\n                xhull = np.concatenate(\n                    [xhull, np.linspace(xhull[-1], xy[0], n_intervals)]\n                )\n                yhull = np.concatenate(\n                    [yhull, np.linspace(yhull[-1], xy[1], n_intervals)]\n                )\n\n            xhull_classes[name_trace] = np.concatenate(\n                [xhull, np.linspace(xhull[-1], x_hullvx[0], n_intervals)]\n            )\n            yhull_classes[name_trace] = np.concatenate(\n                [yhull, np.linspace(yhull[-1], y_hullvx[0], n_intervals)]\n            )\n\n        return xhull_classes, yhull_classes\n\n    def make_line(self, feat_x, feat_y, regr_line_coefs):\n\n        idx_x = self.embedding_features.index(feat_x)\n        idx_y = self.embedding_features.index(feat_y)\n        line_x = np.linspace(self.df[feat_x].min(), self.df[feat_x].max(), 1000)\n\n        # Gives the classifications line\n        if feat_x == feat_y:\n            return line_x, line_x\n        else:\n            line_y = (\n                -line_x * regr_line_coefs[0][idx_x] / regr_line_coefs[0][idx_y]\n                - regr_line_coefs[1] / regr_line_coefs[0][idx_y]\n            )\n            return line_x, line_y\n\n    def marker_style_updates(self, ConfigWidgets):\n        \"\"\"\n        All updates caused by a change in the markers properties.\n        \"\"\"\n\n        self.update_marker_color(ConfigWidgets)\n        self.update_marker_symbol(ConfigWidgets)\n        self.update_marker_size(ConfigWidgets)\n\n    def update_marker_symbol(self, ConfigWidgets):\n        \"\"\"\n        Updates the list of marker symbols for each trace.\n        All markers are initally set to have the symbol specific of the trace \"trace_symbol\".\n        Points whose structure is visualized have a cross as marker.\n        \"\"\"\n\n        for name_trace in self.name_traces:\n\n            self.symbols[name_trace] = [self.trace_symbol[name_trace]] * len(\n                self.df_trace_on_map[name_trace]\n            )\n            formula_l = ConfigWidgets.structure_text_l\n            formula_r = ConfigWidgets.structure_text_r\n\n            for i in range(2):\n                # entries whose structure is visualized appear twice on 'df_trace_on_map'\n                try:\n                    point = np.where(\n                        self.df_trace_on_map[name_trace].index.to_numpy() == formula_l\n                    )[0][i]\n                    self.symbols[name_trace][point] = \"x\"\n                except:\n                    pass\n                try:\n                    point = np.where(\n                        self.df_trace_on_map[name_trace].index.to_numpy() == formula_r\n                    )[0][i]\n                    self.symbols[name_trace][point] = \"cross\"\n                except:\n                    pass\n\n            if formula_l == formula_r and formula_l:\n                try:\n                    point = np.where(\n                        self.df_trace_on_map[name_trace].index.to_numpy() == formula_l\n                    )[0][1]\n                    self.symbols[name_trace][point] = \"x\"\n                    point = np.where(\n                        self.df_trace_on_map[name_trace].index.to_numpy() == formula_l\n                    )[0][2]\n                    self.symbols[name_trace][point] = \"cross\"\n                except:\n                    pass\n\n    def update_marker_size(self, ConfigWidgets):\n        \"\"\"\n        Updates the size of the markers:\n        in case of 'Default size' all markers have the same size, and points marked with x/cross are set with a specific cross size;\n        in case 'Marker' has a feature value, marker sizes are selected according to that specific feature.\n        \"\"\"\n\n        feature = ConfigWidgets.featmarker\n\n        if feature == \"Default size\":\n\n            for name_trace in self.name_traces:\n\n                sizes = [ConfigWidgets.marker_size] * len(\n                    self.df_trace_on_map[name_trace]\n                )\n                symbols = self.symbols[name_trace]\n\n                indices_x = [i for i, symbol in enumerate(symbols) if symbol == \"x\"]\n                indices_cross = [\n                    i for i, symbol in enumerate(symbols) if symbol == \"cross\"\n                ]\n\n                if indices_x:\n                    sizes[indices_x[0]] = ConfigWidgets.cross_size\n\n                if len(indices_x) == 2:\n                    # entries whose structure is visualized appear twice on 'df_trace_on_map'\n\n                    sizes[indices_x[0]] = 0\n                    sizes[indices_x[1]] = ConfigWidgets.cross_size\n\n                if indices_cross:\n                    sizes[indices_cross[0]] = ConfigWidgets.cross_size\n\n                if len(indices_cross) == 2:\n                    sizes[indices_cross[0]] = 0\n                    sizes[indices_cross[1]] = ConfigWidgets.cross_size\n\n                self.sizes[name_trace] = sizes\n        else:\n\n            min_value = ConfigWidgets.min_value_markerfeat\n            max_value = ConfigWidgets.max_value_markerfeat\n            min_feat = min(\n                [\n                    min(self.df_trace_on_map[name_trace][feature].to_numpy())\n                    for name_trace in self.df_trace_on_map\n                ]\n            )\n            max_feat = max(\n                [\n                    max(self.df_trace_on_map[name_trace][feature].to_numpy())\n                    for name_trace in self.df_trace_on_map\n                ]\n            )\n\n            coeff = (max_value - min_value) / (max_feat - min_feat)\n\n            for name_trace in self.name_traces:\n\n                sizes = min_value + coeff * (\n                    self.df_trace_on_map[name_trace][feature].to_numpy() - min_feat\n                )\n                self.sizes[name_trace] = sizes\n\n    def update_marker_color(self, ConfigWidgets):\n        \"\"\"\n        Updates the color of markers:\n        in case of \"Default color\" each trace has a different color;\n        in case of a feature, each different feature value has a different color.\n        \"\"\"\n\n        feature = ConfigWidgets.featcolor\n\n        if feature == \"Default color\":\n\n            palette = cycle(getattr(px.colors.qualitative, ConfigWidgets.color_palette))\n            for name_trace in self.name_traces:\n                self.colors[name_trace] = [next(palette)] * len(\n                    self.df_trace_on_map[name_trace]\n                )\n\n        elif ConfigWidgets.featcolor_type == \"Discrete\":\n            # each color represents a different discrete feature value\n\n            colors_dict = {}\n            palette = cycle(\n                getattr(px.colors.qualitative, ConfigWidgets.featcolor_list)\n            )\n            for value in np.sort(self.df[feature].unique()):\n                colors_dict[value] = next(palette)\n\n            for name_trace in self.name_traces:\n\n                self.colors[name_trace] = [\" \"] * len(self.df_trace_on_map[name_trace])\n                for i, value in enumerate(self.df_trace_on_map[name_trace][feature]):\n\n                    self.colors[name_trace][i] = colors_dict[value]\n\n        elif ConfigWidgets.featcolor_type == \"Gradient\":\n            # colors are interpolated in a gradient, according to the feature value\n\n            feature = ConfigWidgets.featcolor\n\n            for name_trace in self.name_traces:\n                self.colors[name_trace] = self.df_trace_on_map[name_trace][feature]\n\n    def optimize_sequence(self, feat_x, feat_y):\n\n        n_neighbors = 10\n        fraction_thres = 1\n        optimized_sequence_indexes = {}\n\n        for name_trace in self.name_traces:\n\n            name_trace = str(name_trace)\n            feat_x_norm = MinMaxScaler().fit_transform(\n                self.df.loc[self.df[self.target] == name_trace][feat_x].values.reshape(\n                    -1, 1\n                )\n            )\n            feat_y_norm = MinMaxScaler().fit_transform(\n                self.df.loc[self.df[self.target] == name_trace][feat_y].values.reshape(\n                    -1, 1\n                )\n            )\n\n            X = np.concatenate((feat_x_norm, feat_y_norm), axis=1)\n\n            nbrs = NearestNeighbors(n_neighbors=n_neighbors, algorithm=\"ball_tree\").fit(\n                X\n            )\n            nbrs_distances, nbrs_indices = nbrs.kneighbors(X)\n\n            n_values = len(self.df.loc[self.df[self.target] == name_trace])\n\n            remaining_indices = np.arange(n_values)\n\n            new_index = np.array(\n                [remaining_indices[np.argmin(np.sum(nbrs_distances, axis=1))]]\n            )\n            selected_indices = np.array([new_index]).reshape(1)\n            remaining_indices = np.delete(remaining_indices, selected_indices)\n            mask = np.where(nbrs_indices == new_index, 1, 0)\n\n            last_cost = 0\n            bool_cost = True\n\n            while len(remaining_indices) &gt; 0:\n\n                # prob = np.sum(np.exp(distances[remaininig_indexes,:][:,selected_indexes]), axis=1)\n                # prob /= np.sum(prob)\n                # new_index = np.array([np.random.choice(remaininig_indexes, p=prob)])\n\n                # the numerator gives the sum of the distances over the indexes that do not appear on the map\n                # the closer the points that do not appear on the map are, the more likely the point is selected\n                num = np.sum((mask * nbrs_distances)[remaining_indices], axis=1)\n                # the denominater gives the sum of the distances over the indexes that appear on the map\n                # the closer the points that appear on the map are, the less likely the point is selected\n                den = np.sum(((1 - mask) * nbrs_distances)[remaining_indices], axis=1)\n                if np.min(num) == 0:\n                    arg = np.argmax(den[np.where(num == 0)])\n                    new_index = np.array([remaining_indices[np.where(num == 0)][arg]])\n                    new_cost = 0\n                elif np.min(den) == 0:\n                    arg = np.argmin(num[np.where(den == 0)])\n                    new_index = np.array([remaining_indices[np.where(den == 0)][arg]])\n                    new_cost = float(\"inf\")\n                else:\n                    arg = np.argmin(num / den)\n                    new_index = np.array([remaining_indices[arg]])\n                    new_cost = (num / den)[arg]\n\n                if bool_cost:\n                    if new_cost &gt; 1 and last_cost &lt; 1:\n                        fraction_thres = len(selected_indices) / n_values\n                        # fractions_thres [(feat_x, feat_y)] = len(selected_indexes)/len(distances)\n                        # fractions_thres [(feat_y, feat_x)] = len(selected_indexes)/len(distances)\n                        bool_cost = False\n                    last_cost = new_cost\n\n                remaining_indices = np.delete(\n                    remaining_indices, np.where(remaining_indices == new_index)\n                )\n                selected_indices = np.concatenate((selected_indices, new_index))\n                mask = mask + np.where(nbrs_indices == new_index, 1, 0)\n\n                if len(remaining_indices &gt; 0) and len(remaining_indices) % 10 == 0:\n                    arg = np.argmax(\n                        np.sum((mask * nbrs_distances)[remaining_indices], axis=1)\n                    )\n                    new_index = np.array([remaining_indices[arg]])\n                    remaining_indices = np.delete(\n                        remaining_indices, np.where(remaining_indices == new_index)\n                    )\n                    selected_indices = np.concatenate((selected_indices, new_index))\n                    mask = mask + np.where(nbrs_indices == new_index, 1, 0)\n\n            optimized_sequence_indexes[name_trace] = self.df[\n                self.df[self.target] == name_trace\n            ].index.to_numpy()[selected_indices]\n\n        return optimized_sequence_indexes, fraction_thres\n</code></pre>"},{"location":"references/#nomad_visu.figure.Figure.batch_update","title":"<code>batch_update(ConfigWidgets)</code>","text":"<p>Updates the layout of the map according to values stored in \"ConfigWidgets\".</p>  Source code in <code>nomad_visu/figure/__init__.py</code> <pre><code>def batch_update(self, ConfigWidgets):\n    \"\"\"\n    Updates the layout of the map according to values stored in \"ConfigWidgets\".\n    \"\"\"\n\n    self.marker_style_updates(ConfigWidgets)\n    self.fract_change_updates(ConfigWidgets)\n\n    x_min = []\n    x_max = []\n    y_min = []\n    y_max = []\n\n    for name_trace in self.name_traces:\n\n        x_min.append(min(self.df_trace_on_map[name_trace][ConfigWidgets.feat_x]))\n        x_max.append(max(self.df_trace_on_map[name_trace][ConfigWidgets.feat_x]))\n        y_min.append(min(self.df_trace_on_map[name_trace][ConfigWidgets.feat_y]))\n        y_max.append(max(self.df_trace_on_map[name_trace][ConfigWidgets.feat_y]))\n\n    x_min = min(x_min)\n    y_min = min(y_min)\n    x_max = max(x_max)\n    y_max = max(y_max)\n    x_delta = 0.05 * abs(x_max - x_min)\n    y_delta = 0.05 * abs(y_max - y_min)\n\n    # range of the x-,y- values that are visualized on the map\n    xaxis_range = [x_min - x_delta, x_max + x_delta]\n    yaxis_range = [y_min - y_delta, y_max + y_delta]\n\n    if ConfigWidgets.bg_toggle:\n        bg_color = ConfigWidgets.bg_color\n        gridcolor = \"white\"\n    else:\n        bg_color = \"white\"\n        gridcolor = \"rgb(229,236,246)\"\n\n    with self.FigureWidget.batch_update():\n\n        self.FigureWidget.update_layout(\n            showlegend=True,\n            plot_bgcolor=bg_color,\n            xaxis=dict(gridcolor=gridcolor, showgrid=True, zeroline=False),\n            yaxis=dict(gridcolor=gridcolor, showgrid=True, zeroline=False),\n            font=dict(\n                size=int(ConfigWidgets.font_size),\n                family=ConfigWidgets.font_family,\n                color=ConfigWidgets.font_color,\n            ),\n            xaxis_title=ConfigWidgets.feat_x,\n            yaxis_title=ConfigWidgets.feat_y,\n            xaxis_range=xaxis_range,\n            yaxis_range=yaxis_range,\n        )\n\n        for name_trace in self.name_traces:\n            # all elements on the map and their properties are reinitialized at each change\n\n            self.FigureWidget.update_traces(\n                selector={\"name\": str(name_trace)},\n                text=self.hover_text[name_trace],\n                customdata=self.hover_custom[name_trace],\n                hovertemplate=self.hover_template[name_trace],\n                x=self.df_trace_on_map[name_trace][ConfigWidgets.feat_x],\n                y=self.df_trace_on_map[name_trace][ConfigWidgets.feat_y],\n                marker=dict(\n                    size=self.sizes[name_trace], symbol=self.symbols[name_trace]\n                ),\n            )\n            if (\n                ConfigWidgets.featcolor != \"Default color\"\n                and ConfigWidgets.featcolor_type == \"Gradient\"\n            ):\n                feature = ConfigWidgets.featcolor\n                gradient = ConfigWidgets.featcolor_list\n                min_value = self.df[feature].min()\n                max_value = self.df[feature].max()\n\n                self.FigureWidget.update_traces(\n                    selector={\"name\": str(name_trace)},\n                    marker=dict(\n                        colorscale=gradient,\n                        showscale=True,\n                        color=self.colors[name_trace],\n                        cmin=min_value,\n                        cmax=max_value,\n                        colorbar=dict(\n                            thickness=10,\n                            orientation=\"v\",\n                            len=0.5,\n                            y=0.25,\n                            title=dict(\n                                text=feature, side=\"right\", font={\"size\": 10}\n                            ),\n                        ),\n                    ),\n                )\n            else:\n                self.FigureWidget.update_traces(\n                    selector={\"name\": str(name_trace)},\n                    marker=dict(showscale=False, color=self.colors[name_trace]),\n                )\n        if (ConfigWidgets.feat_x, ConfigWidgets.feat_y) in self.regr_line_trace:\n            name_trace = (\n                \"Regr line\"\n                + str(ConfigWidgets.feat_x)\n                + \" \"\n                + (ConfigWidgets.feat_y)\n            )\n\n            if self.regr_line_trace[(ConfigWidgets.feat_x, ConfigWidgets.feat_y)]:\n                self.trace[name_trace].line = dict(\n                    color=ConfigWidgets.line_color,\n                    width=ConfigWidgets.line_width,\n                    dash=ConfigWidgets.line_dash,\n                )\n            else:\n                self.trace[name_trace].line = dict(width=0)\n\n        if self.convex_hull == True:\n\n            if ConfigWidgets.feat_x == ConfigWidgets.feat_y:\n\n                for name_trace in self.name_traces:\n\n                    self.trace[\"Hull \" + str(name_trace)].line = dict(width=0)\n                    self.FigureWidget.update_traces(\n                        selector={\"name\": \"Hull \" + name_trace},\n                    )\n            else:\n                hullx, hully = self.make_hull(\n                    ConfigWidgets.feat_x, ConfigWidgets.feat_y\n                )\n                for name_trace in self.name_traces:\n\n                    self.trace[\"Hull \" + str(name_trace)][\"x\"] = hullx[name_trace]\n                    self.trace[\"Hull \" + str(name_trace)][\"y\"] = hully[name_trace]\n                    self.trace[\"Hull \" + str(name_trace)].line = dict(\n                        color=ConfigWidgets.hull_color,\n                        width=ConfigWidgets.hull_width,\n                        dash=ConfigWidgets.hull_dash,\n                    )\n                    self.FigureWidget.update_traces(\n                        selector={\"name\": \"Hull \" + name_trace}, showlegend=False\n                    )\n        else:\n            for name_trace in self.name_traces:\n\n                self.trace[\"Hull \" + str(name_trace)].line = dict(width=0)\n                self.FigureWidget.update_traces(\n                    selector={\"name\": \"Hull \" + str(name_trace)},\n                )\n</code></pre>"},{"location":"references/#nomad_visu.figure.Figure.fract_change_updates","title":"<code>fract_change_updates(ConfigWidgets)</code>","text":"<p>All updates caused by a change in the fraction value.</p>  Source code in <code>nomad_visu/figure/__init__.py</code> <pre><code>def fract_change_updates(self, ConfigWidgets):\n    \"\"\"\n    All updates caused by a change in the fraction value.\n    \"\"\"\n\n    self.update_df_on_map(ConfigWidgets)\n    self.update_hover_variables()\n</code></pre>"},{"location":"references/#nomad_visu.figure.Figure.marker_style_updates","title":"<code>marker_style_updates(ConfigWidgets)</code>","text":"<p>All updates caused by a change in the markers properties.</p>  Source code in <code>nomad_visu/figure/__init__.py</code> <pre><code>def marker_style_updates(self, ConfigWidgets):\n    \"\"\"\n    All updates caused by a change in the markers properties.\n    \"\"\"\n\n    self.update_marker_color(ConfigWidgets)\n    self.update_marker_symbol(ConfigWidgets)\n    self.update_marker_size(ConfigWidgets)\n</code></pre>"},{"location":"references/#nomad_visu.figure.Figure.update_df_on_map","title":"<code>update_df_on_map(ConfigWidgets)</code>","text":"<p>Updates the number of points based on the fraction value, then 'df_trace_on_map' which is the fraction of the dataframe that is visualized</p>  Source code in <code>nomad_visu/figure/__init__.py</code> <pre><code>def update_df_on_map(self, ConfigWidgets):\n    \"\"\"\n    Updates the number of points based on the fraction value,\n    then 'df_trace_on_map' which is the fraction of the dataframe that is visualized\n    \"\"\"\n\n    for name_trace in self.name_traces:\n\n        n_points = int(\n            ConfigWidgets.fract\n            * self.df.loc[self.df[self.target] == name_trace].shape[0]\n        )\n\n        if n_points &lt; 1:\n            n_points = 1\n\n        if (\n            ConfigWidgets.feat_x,\n            ConfigWidgets.feat_y,\n        ) in self.optimized_sequence_indexes:\n            sequence_indexes = self.optimized_sequence_indexes[\n                (ConfigWidgets.feat_x, ConfigWidgets.feat_y)\n            ][name_trace]\n        else:\n            sequence_indexes = self.random_permutation_indexes[name_trace]\n\n        self.df_trace_on_map[name_trace] = (\n            self.df.loc[self.df[self.target] == name_trace]\n            .loc[sequence_indexes]\n            .head(n_points)\n        )\n\n        # if a structure is visualized, its dataframe entry is added to the visualized dataframe 'df_trace_on_map'\n        # this to avoid that the entry relative to a visualized structure is not available on the map\n        if (\n            ConfigWidgets.structure_text_l\n            in self.df.loc[self.df[self.target] == name_trace].index\n        ):\n            self.df_trace_on_map[name_trace] = pd.concat(\n                [\n                    self.df_trace_on_map[name_trace],\n                    self.df.loc[[ConfigWidgets.structure_text_l]],\n                ]\n            )\n\n        if (\n            ConfigWidgets.structure_text_r\n            in self.df.loc[self.df[self.target] == name_trace].index\n        ):\n            self.df_trace_on_map[name_trace] = pd.concat(\n                [\n                    self.df_trace_on_map[name_trace],\n                    self.df.loc[[ConfigWidgets.structure_text_r]],\n                ]\n            )\n</code></pre>"},{"location":"references/#nomad_visu.figure.Figure.update_hover_variables","title":"<code>update_hover_variables()</code>","text":"<p>Updates the hover data based on the points that are visualized on the map.</p>  Source code in <code>nomad_visu/figure/__init__.py</code> <pre><code>def update_hover_variables(self):\n    \"\"\"\n    Updates the hover data based on the points that are visualized on the map.\n    \"\"\"\n\n    self.hover_text = {}\n    self.hover_custom = {}\n    self.hover_template = {}\n\n    for name_trace in self.name_traces:\n\n        self.hover_text[name_trace] = self.df_trace_on_map[name_trace].index\n        hover_template = r\"&lt;b&gt;%{text}&lt;/b&gt;&lt;br&gt;&lt;br&gt;\"\n        if self.hover_features:\n            hover_custom = np.dstack(\n                [\n                    self.df_trace_on_map[name_trace][\n                        str(self.hover_features[0])\n                    ].to_numpy()\n                ]\n            )\n            hover_template += str(self.hover_features[0]) + \": %{customdata[0]}&lt;br&gt;\"\n            for i in range(1, len(self.hover_features), 1):\n                hover_custom = np.dstack(\n                    [\n                        hover_custom,\n                        self.df_trace_on_map[name_trace][\n                            str(self.hover_features[i])\n                        ].to_numpy(),\n                    ]\n                )\n                hover_template += (\n                    str(self.hover_features[i])\n                    + \": %{customdata[\"\n                    + str(i)\n                    + \"]}&lt;br&gt;\"\n                )\n            self.hover_custom[name_trace] = hover_custom[0]\n            self.hover_template[name_trace] = hover_template\n        else:\n            self.hover_customp[name_trace] = [\"\"]\n            self.hover_template[name_trace] = [\"\"]\n</code></pre>"},{"location":"references/#nomad_visu.figure.Figure.update_marker_color","title":"<code>update_marker_color(ConfigWidgets)</code>","text":"<p>Updates the color of markers: in case of \"Default color\" each trace has a different color; in case of a feature, each different feature value has a different color.</p>  Source code in <code>nomad_visu/figure/__init__.py</code> <pre><code>def update_marker_color(self, ConfigWidgets):\n    \"\"\"\n    Updates the color of markers:\n    in case of \"Default color\" each trace has a different color;\n    in case of a feature, each different feature value has a different color.\n    \"\"\"\n\n    feature = ConfigWidgets.featcolor\n\n    if feature == \"Default color\":\n\n        palette = cycle(getattr(px.colors.qualitative, ConfigWidgets.color_palette))\n        for name_trace in self.name_traces:\n            self.colors[name_trace] = [next(palette)] * len(\n                self.df_trace_on_map[name_trace]\n            )\n\n    elif ConfigWidgets.featcolor_type == \"Discrete\":\n        # each color represents a different discrete feature value\n\n        colors_dict = {}\n        palette = cycle(\n            getattr(px.colors.qualitative, ConfigWidgets.featcolor_list)\n        )\n        for value in np.sort(self.df[feature].unique()):\n            colors_dict[value] = next(palette)\n\n        for name_trace in self.name_traces:\n\n            self.colors[name_trace] = [\" \"] * len(self.df_trace_on_map[name_trace])\n            for i, value in enumerate(self.df_trace_on_map[name_trace][feature]):\n\n                self.colors[name_trace][i] = colors_dict[value]\n\n    elif ConfigWidgets.featcolor_type == \"Gradient\":\n        # colors are interpolated in a gradient, according to the feature value\n\n        feature = ConfigWidgets.featcolor\n\n        for name_trace in self.name_traces:\n            self.colors[name_trace] = self.df_trace_on_map[name_trace][feature]\n</code></pre>"},{"location":"references/#nomad_visu.figure.Figure.update_marker_size","title":"<code>update_marker_size(ConfigWidgets)</code>","text":"<p>Updates the size of the markers: in case of 'Default size' all markers have the same size, and points marked with x/cross are set with a specific cross size; in case 'Marker' has a feature value, marker sizes are selected according to that specific feature.</p>  Source code in <code>nomad_visu/figure/__init__.py</code> <pre><code>def update_marker_size(self, ConfigWidgets):\n    \"\"\"\n    Updates the size of the markers:\n    in case of 'Default size' all markers have the same size, and points marked with x/cross are set with a specific cross size;\n    in case 'Marker' has a feature value, marker sizes are selected according to that specific feature.\n    \"\"\"\n\n    feature = ConfigWidgets.featmarker\n\n    if feature == \"Default size\":\n\n        for name_trace in self.name_traces:\n\n            sizes = [ConfigWidgets.marker_size] * len(\n                self.df_trace_on_map[name_trace]\n            )\n            symbols = self.symbols[name_trace]\n\n            indices_x = [i for i, symbol in enumerate(symbols) if symbol == \"x\"]\n            indices_cross = [\n                i for i, symbol in enumerate(symbols) if symbol == \"cross\"\n            ]\n\n            if indices_x:\n                sizes[indices_x[0]] = ConfigWidgets.cross_size\n\n            if len(indices_x) == 2:\n                # entries whose structure is visualized appear twice on 'df_trace_on_map'\n\n                sizes[indices_x[0]] = 0\n                sizes[indices_x[1]] = ConfigWidgets.cross_size\n\n            if indices_cross:\n                sizes[indices_cross[0]] = ConfigWidgets.cross_size\n\n            if len(indices_cross) == 2:\n                sizes[indices_cross[0]] = 0\n                sizes[indices_cross[1]] = ConfigWidgets.cross_size\n\n            self.sizes[name_trace] = sizes\n    else:\n\n        min_value = ConfigWidgets.min_value_markerfeat\n        max_value = ConfigWidgets.max_value_markerfeat\n        min_feat = min(\n            [\n                min(self.df_trace_on_map[name_trace][feature].to_numpy())\n                for name_trace in self.df_trace_on_map\n            ]\n        )\n        max_feat = max(\n            [\n                max(self.df_trace_on_map[name_trace][feature].to_numpy())\n                for name_trace in self.df_trace_on_map\n            ]\n        )\n\n        coeff = (max_value - min_value) / (max_feat - min_feat)\n\n        for name_trace in self.name_traces:\n\n            sizes = min_value + coeff * (\n                self.df_trace_on_map[name_trace][feature].to_numpy() - min_feat\n            )\n            self.sizes[name_trace] = sizes\n</code></pre>"},{"location":"references/#nomad_visu.figure.Figure.update_marker_symbol","title":"<code>update_marker_symbol(ConfigWidgets)</code>","text":"<p>Updates the list of marker symbols for each trace. All markers are initally set to have the symbol specific of the trace \"trace_symbol\". Points whose structure is visualized have a cross as marker.</p>  Source code in <code>nomad_visu/figure/__init__.py</code> <pre><code>def update_marker_symbol(self, ConfigWidgets):\n    \"\"\"\n    Updates the list of marker symbols for each trace.\n    All markers are initally set to have the symbol specific of the trace \"trace_symbol\".\n    Points whose structure is visualized have a cross as marker.\n    \"\"\"\n\n    for name_trace in self.name_traces:\n\n        self.symbols[name_trace] = [self.trace_symbol[name_trace]] * len(\n            self.df_trace_on_map[name_trace]\n        )\n        formula_l = ConfigWidgets.structure_text_l\n        formula_r = ConfigWidgets.structure_text_r\n\n        for i in range(2):\n            # entries whose structure is visualized appear twice on 'df_trace_on_map'\n            try:\n                point = np.where(\n                    self.df_trace_on_map[name_trace].index.to_numpy() == formula_l\n                )[0][i]\n                self.symbols[name_trace][point] = \"x\"\n            except:\n                pass\n            try:\n                point = np.where(\n                    self.df_trace_on_map[name_trace].index.to_numpy() == formula_r\n                )[0][i]\n                self.symbols[name_trace][point] = \"cross\"\n            except:\n                pass\n\n        if formula_l == formula_r and formula_l:\n            try:\n                point = np.where(\n                    self.df_trace_on_map[name_trace].index.to_numpy() == formula_l\n                )[0][1]\n                self.symbols[name_trace][point] = \"x\"\n                point = np.where(\n                    self.df_trace_on_map[name_trace].index.to_numpy() == formula_l\n                )[0][2]\n                self.symbols[name_trace][point] = \"cross\"\n            except:\n                pass\n</code></pre>"}]}